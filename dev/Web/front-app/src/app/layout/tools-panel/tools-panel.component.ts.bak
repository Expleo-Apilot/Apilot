import { Component, OnInit, ViewChild, ElementRef } from '@angular/core';
import { LlmFactoryService, LlmType } from '../../core/services/llm-factory.service';
import { LlmService } from '../../core/services/llm.service';
import { TestRunnerService, TestResult, TestResponse } from '../../core/services/test-runner.service';
import { NgIf } from '@angular/common';
import { catchError, finalize, of } from 'rxjs';

// Monaco editor options interface
interface EditorOptions {
  theme: string;
  language: string;
  automaticLayout: boolean;
  minimap: { enabled: boolean };
  scrollBeyondLastLine: boolean;
  fontSize: number;
  tabSize: number;
  wordWrap: string;
}

// TestResult interface is now imported from test-runner.service.ts

@Component({
  selector: 'app-tools-panel',
  standalone: false,
  templateUrl: './tools-panel.component.html',
  styleUrl: './tools-panel.component.css'
})
export class ToolsPanelComponent implements OnInit {
  // Editor configuration
  editorOptions: EditorOptions = {
    theme: 'vs-light',
    language: 'csharp',
    automaticLayout: true,
    minimap: { enabled: false },
    scrollBeyondLastLine: false,
    fontSize: 14,
    tabSize: 2,
    wordWrap: 'on'
  };

  // Test script code
  testScript: string = '';

  // Test results
  testResults: TestResult[] = [];
  isRunning: boolean = false;
  hasRun: boolean = false;
  allTestsPassed: boolean = true;
  totalTests: number = 0;
  passedTests: number = 0;

  // Selected tab
  activeTab: 'script' | 'results' = 'script';

  // Prompt input
  promptInput: string = '';
  isProcessingPrompt: boolean = false;
  promptHistory: string[] = [];
  currentHistoryIndex: number = -1;
  errorMessage: string = '';

  // LLM selection
  availableLlmTypes: LlmType[] = [];
  selectedLlmType: LlmType = LlmType.OLLAMA;
  currentModelName: string = '';

  // Real-time typing effect
  private typingInterval: any;
  private typingSpeed: number = 10; // ms per character
  private currentTypingText: string = '';
  private targetTypingText: string = '';
  private typingPosition: number = 0;
  private typingPrompt: string = '';

  constructor(private llmFactoryService: LlmFactoryService, private testRunnerService: TestRunnerService) { }

  ngOnInit(): void {
    // Initialize with a sample test script
    this.testScript = this.getSampleTestScript();

    // Load prompt history from localStorage if available
    this.loadPromptHistory();

    // Initialize LLM types and selection
    this.availableLlmTypes = this.llmFactoryService.getAllLlmTypes();
    this.selectedLlmType = this.llmFactoryService.getCurrentLlmType();
    this.updateCurrentModelName();
  }

  /**
   * Run the test script
   */
  runTests(): void {
    if (!this.testScript || this.testScript.trim() === '') {
      this.errorMessage = 'Please enter a test script before running tests.';
      setTimeout(() => this.errorMessage = '', 3000);
      return;
    }

    this.isRunning = true;
    this.hasRun = true;
    this.testResults = [];
    this.errorMessage = '';

    this.testRunnerService.runTests(this.testScript).subscribe(
      (response: TestResponse) => {
        if (response.success) {
          this.testResults = response.results;
          this.totalTests = response.totalTests;
          this.passedTests = response.passedTests;
          this.allTestsPassed = this.passedTests === this.totalTests;
        } else {
          // Handle server-side error with the test execution
          this.testResults = [{
            name: 'Test Execution Error',
            passed: false,
            message: response.errorMessage || 'The server encountered an error while executing tests',
            duration: 0
          }];
          this.totalTests = 1;
          this.passedTests = 0;
          this.allTestsPassed = false;
        }
        this.activeTab = 'results';
      },
      (error) => {
        console.error('Error running tests:', error);

        // Determine if it's a connection error or other HTTP error
        let errorMessage = 'Failed to run tests';

        if (error.status === 0) {
          errorMessage = 'Cannot connect to the test runner service. Please make sure the backend API is running.';
        } else if (error.status >= 400) {
          errorMessage = `Server error (${error.status}): ${error.error?.message || error.statusText || 'Unknown error'}`;
        } else if (error.message) {
          errorMessage = error.message;
        }

        this.testResults = [{
          name: 'Test Runner Error',
          passed: false,
          message: errorMessage,
          duration: 0
        }];
        this.totalTests = 1;
        this.passedTests = 0;
        this.allTestsPassed = false;
        this.activeTab = 'results';
      },
      () => {
        this.isRunning = false;
      }
    );
  }

  /**
   * Switch between script and results tabs
   */
  switchTab(tab: 'script' | 'results'): void {
    this.activeTab = tab;
  }

  /**
   * Clear test results
   */
  clearResults(): void {
    this.testResults = [];
    this.hasRun = false;
    this.totalTests = 0;
    this.passedTests = 0;
  }

  /**
   * Get a sample test script for demonstration
   */
  private  getSampleTestScript(): string {
    return `// Sample Test Script
// This demonstrates how to write tests using the test framework

Test("Math Test", () => {
    // A simple test that checks basic math operations
    int result = 2 + 2;
    Assert(result == 4, "2 + 2 should equal 4");
    return true;
});

Test("String Test", () => {
    // A simple test that checks string operations
    string test = "Hello" + " " + "World";
    Assert(test == "Hello World", "String concatenation should work correctly");
    return true;
});

// Basic API Test Example
TestAsync("Simple API Test", async () => {
    // Create a client with a base URL
    var client = ConfigureClient("https://jsonplaceholder.typicode.com");
    
    // Make a GET request
    var response = await client.GetAsync("/posts/1");
    
    // Assert that the response status code is 200 OK
    AssertStatusCode(response, HttpStatusCode.OK);
    
    // Parse the JSON response using JsonElement
    var jsonResult = ParseJsonResponse(response);
    
    // Check if properties exist
    Assert(JsonPropertyExists(jsonResult, "id"), "Response should contain 'id' property");
    Assert(JsonPropertyExists(jsonResult, "title"), "Response should contain 'title' property");
    
    // Check property values
    Assert(JsonPropertyEquals(jsonResult, "id", 1), "Post ID should be 1");
    
    return true;
});

// POST Request Example with JSON
TestAsync("POST API Test", async () => {
    // Create a client with a base URL
    var client = ConfigureClient("https://jsonplaceholder.typicode.com");
    
    // Create content for the POST request
    var content = new StringContent(
        JsonSerializer.Serialize(new { 
            title = "Test Post", 
            body = "This is a test post", 
            userId = 1 
        }),
        Encoding.UTF8,
        "application/json"
    );
    
    // Make a POST request
    var response = await client.PostAsync("/posts", content);
    
    // Assert that the response status code is in the success range (200-299)
    AssertStatusCodeRange(response, 200, 299);
    
    // Parse the JSON response
    var jsonResult = ParseJsonResponse(response);
    
    // Check if the created post has an ID
    Assert(JsonPropertyExists(jsonResult, "id"), "Created post should have an ID");
    Assert(JsonPropertyExists(jsonResult, "title"), "Created post should have a title");
    Assert(JsonPropertyEquals(jsonResult, "title", "Test Post"), "Post title should match what we sent");
    
    return true;
});

// Complex Nested JSON Example
TestAsync("Nested JSON Test", async () => {
    // Create a client with a base URL
    var client = ConfigureClient("https://api.github.com", new Dictionary<string, string> {
        { "User-Agent", "API-Test-Framework" }
    });
    
    // Make a GET request to GitHub API
    var response = await client.GetAsync("/repos/microsoft/vscode");
    
    // Assert that the response status code is OK
    AssertStatusCode(response, HttpStatusCode.OK);
    
    // Parse the JSON response
    var jsonResult = ParseJsonResponse(response);
    
    // Check basic properties
    Assert(JsonPropertyExists(jsonResult, "name"), "Repository should have a name");
    Assert(JsonPropertyEquals(jsonResult, "name", "vscode"), "Repository name should be 'vscode'");
    
    // Check nested properties manually
    // Get the owner object
    if (jsonResult.TryGetProperty("owner", out JsonElement ownerElement)) {
        // Check owner properties
        Assert(JsonPropertyExists(ownerElement, "login"), "Owner should have a login name");
        Assert(JsonPropertyEquals(ownerElement, "login", "microsoft"), "Owner login should be 'microsoft'");
        
        // Check nested properties manually
        if (ownerElement.TryGetProperty("type", out JsonElement typeElement)) {
            Assert(typeElement.GetString() == "Organization", "Owner type should be 'Organization'");
        }
        else {
            Assert(false, "Owner should have a type property");
        }
    }
    else {
        Assert(false, "Repository should have an owner property");
    }
    
    return true;
});

// Array Data Test Example
TestAsync("JSON Array Test", async () => {
    // Create a client with a base URL
    var client = ConfigureClient("https://jsonplaceholder.typicode.com");
    
    // Make a GET request to fetch a list of users
    var response = await client.GetAsync("/users");
    
    // Assert that the response status code is OK
    AssertStatusCode(response, HttpStatusCode.OK);
    
    // Parse the JSON response (which should be an array)
    var jsonResult = ParseJsonResponse(response);
    
    // Verify we got an array
    Assert(jsonResult.ValueKind == JsonValueKind.Array, "Response should be a JSON array");
    
    // Check if the array contains a user with a specific username using manual iteration
    bool foundBretUser = false;
    bool foundUserWithBizEmail = false;
    
    foreach (JsonElement user in jsonResult.EnumerateArray()) {
        // Check for user with username "Bret"
        if (user.TryGetProperty("username", out JsonElement usernameProp) && 
            usernameProp.ValueKind == JsonValueKind.String && 
            usernameProp.GetString() == "Bret") {
            foundBretUser = true;
        }
        
        // Check for user with .biz email domain
        if (user.TryGetProperty("email", out JsonElement emailProp) && 
            emailProp.ValueKind == JsonValueKind.String && 
            emailProp.GetString().EndsWith(".biz")) {
            foundUserWithBizEmail = true;
        }
        
        // If we found both, we can break early
        if (foundBretUser && foundUserWithBizEmail) {
            break;
        }
    }
    
    Assert(foundBretUser, "User array should contain a user with username 'Bret'");
    Assert(foundUserWithBizEmail, "Should find at least one user with a .biz email domain");
    
    return true;
});`;
  }

  /**
   * Process the prompt input and generate code using selected LLM
   */
  /**
   * Process the prompt input and generate code using selected LLM
   */
  processPrompt(): void {
    if (!this.promptInput.trim()) return;

    this.isProcessingPrompt = true;
    this.errorMessage = '';
    const userPrompt = this.promptInput.trim();
    this.typingPrompt = userPrompt;

    // Add to history
    this.addToPromptHistory(userPrompt);

    // Clear input field
    this.promptInput = '';

    // Stop any ongoing typing animation
    this.stopTypingAnimation();

    // Get the current LLM service
    const llmService = this.llmFactoryService.getCurrentLlm();
    
    // Enhance the prompt with specific instructions for API testing
    const enhancedPrompt = `Generate C# API test code for the following requirement: "${userPrompt}"

Please follow these guidelines for creating high-quality API tests:

1. Use the provided helper methods: AssertStatusCode, AssertStatusCodeRange, JsonPropertyEquals, JsonPropertyExists
2. For nested JSON properties, use the TryGetProperty pattern instead of GetNestedJsonProperty
3. For JSON arrays, iterate through them manually instead of using JsonArrayContains
4. Include proper error handling with try/catch blocks
5. Add descriptive comments and meaningful assertion messages
6. Structure tests with proper setup, execution, and verification phases
7. Include validation for both happy path and error scenarios
8. Add appropriate timeouts for API calls
9. Use appropriate HTTP methods (GET, POST, PUT, DELETE) based on the operation
10. Format the response as valid, compilable C# code only

Return ONLY the C# test code without any explanations or markdown formatting.`;

    // Call the LLM service to generate test code
    llmService.generateTestCode(enhancedPrompt)
      .pipe(
        catchError(error => {
          console.error(`Error calling ${llmService.getModelName()} API:`, error);
          this.errorMessage = `Error: ${error.message || `Failed to connect to ${llmService.getModelName()}. Please check your connection.`}`;
          return of(null);
        }),
        finalize(() => {
          this.isProcessingPrompt = false;
        })
      )
      .subscribe(response => {
        if (response) {
          // Extract and clean the generated code
          const generatedCode = this.cleanGeneratedCode(response.response);

          // Prepare the text to be typed
          let newContent = '';
          if (this.testScript && this.testScript.trim()) {
            // Append to existing code with a separator
            newContent = this.testScript + '\n\n// Generated from prompt: "' + userPrompt + '" using ' + llmService.getModelName() + '\n' + generatedCode;
          } else {
            // Set as new code
            newContent = '// Generated from prompt: "' + userPrompt + '" using ' + llmService.getModelName() + '\n' + generatedCode;
          }

          // Start the typing animation
          this.startTypingAnimation(newContent);
        }
      });
  }

  /**
   * Handle key events in the prompt input
   */
  handlePromptKeyEvent(event: KeyboardEvent): void {
    // Handle Enter key to submit
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      this.processPrompt();
    }

    // Handle Up arrow for history navigation
    if (event.key === 'ArrowUp') {
      if (this.currentHistoryIndex < this.promptHistory.length - 1) {
        this.currentHistoryIndex++;
        this.promptInput = this.promptHistory[this.promptHistory.length - 1 - this.currentHistoryIndex];
        event.preventDefault();
      }
    }

    // Handle Down arrow for history navigation
    if (event.key === 'ArrowDown') {
      if (this.currentHistoryIndex > 0) {
        this.currentHistoryIndex--;
        this.promptInput = this.promptHistory[this.promptHistory.length - 1 - this.currentHistoryIndex];
        event.preventDefault();
      } else if (this.currentHistoryIndex === 0) {
        this.currentHistoryIndex = -1;
        this.promptInput = '';
        event.preventDefault();
      }
    }
  }

  /**
   * Add a prompt to the history
   */
  private addToPromptHistory(prompt: string): void {
    // Add to the beginning of the array
    this.promptHistory.push(prompt);

    // Limit history size
    if (this.promptHistory.length > 20) {
      this.promptHistory.shift();
    }

    // Reset current index
    this.currentHistoryIndex = -1;

    // Save to localStorage
    this.savePromptHistory();
  }

  /**
   * Save prompt history to localStorage
   */
  private savePromptHistory(): void {
    try {
      localStorage.setItem('promptHistory', JSON.stringify(this.promptHistory));
    } catch (error) {
      console.error('Error saving prompt history:', error);
    }
  }

  /**
   * Load prompt history from localStorage
   */
  private loadPromptHistory(): void {
    try {
      const history = localStorage.getItem('promptHistory');
      if (history) {
        this.promptHistory = JSON.parse(history);
      }
    } catch (error) {
      console.error('Error loading prompt history:', error);
    }
  }

  /**
   * Start the typing animation effect
   * @param targetText The complete text that should be displayed when animation completes
   */
  private startTypingAnimation(targetText: string): void {
    // Store the current and target text
    this.currentTypingText = this.testScript;
    this.targetTypingText = targetText;
    this.typingPosition = this.currentTypingText.length;

    // Start the interval to add characters one by one
    this.typingInterval = setInterval(() => this.typeNextCharacter(), this.typingSpeed);
  }

  /**
   * Type the next character in the animation sequence
   */
  private typeNextCharacter(): void {
    // Check if we've reached the end of the target text
    if (this.typingPosition >= this.targetTypingText.length) {
      this.stopTypingAnimation();
      return;
    }

    // Add the next character
    this.typingPosition++;
    this.testScript = this.targetTypingText.substring(0, this.typingPosition);
  }

  /**
   * Stop the typing animation
   */
  private stopTypingAnimation(): void {
    if (this.typingInterval) {
      clearInterval(this.typingInterval);
      this.typingInterval = null;

      // Ensure the full text is displayed
      if (this.targetTypingText) {
        this.testScript = this.targetTypingText;
      }
    }
  }

  /**
   * Change the selected LLM type
   * @param llmType The LLM type to switch to
   */
  changeLlmType(llmType: LlmType): void {
    this.selectedLlmType = llmType;
    this.llmFactoryService.setCurrentLlmType(llmType);
    this.updateCurrentModelName();
  }

  /**
   * Update the current model name display
   */
  private updateCurrentModelName(): void {
}

/**
 * Handle key events in the prompt input
 */
handlePromptKeyEvent(event: KeyboardEvent): void {
  // Handle Enter key to submit
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    this.processPrompt();
  }

  // Handle Up arrow for history navigation
  if (event.key === 'ArrowUp') {
    if (this.currentHistoryIndex < this.promptHistory.length - 1) {
      this.currentHistoryIndex++;
      this.promptInput = this.promptHistory[this.promptHistory.length - 1 - this.currentHistoryIndex];
      event.preventDefault();
    }
  }

  // Handle Down arrow for history navigation
  if (event.key === 'ArrowDown') {
    if (this.currentHistoryIndex > 0) {
      this.currentHistoryIndex--;
      this.promptInput = this.promptHistory[this.promptHistory.length - 1 - this.currentHistoryIndex];
      event.preventDefault();
    } else if (this.currentHistoryIndex === 0) {
      this.currentHistoryIndex = -1;
      this.promptInput = '';
      event.preventDefault();
    }
  }
}

/**
 * Add a prompt to the history
 */
private addToPromptHistory(prompt: string): void {
  // Add to the beginning of the array
  this.promptHistory.push(prompt);

  // Limit history size
  if (this.promptHistory.length > 20) {
    this.promptHistory.shift();
  }

  // Reset current index
  this.currentHistoryIndex = -1;

  // Save to localStorage
  this.savePromptHistory();
}

/**
 * Save prompt history to localStorage
 */
private savePromptHistory(): void {
  try {
    localStorage.setItem('promptHistory', JSON.stringify(this.promptHistory));
  } catch (error) {
    console.error('Error saving prompt history:', error);
  }
}

/**
 * Load prompt history from localStorage
 */
private loadPromptHistory(): void {
  try {
    const history = localStorage.getItem('promptHistory');
    if (history) {
      this.promptHistory = JSON.parse(history);
    }
  } catch (error) {
    console.error('Error loading prompt history:', error);
  }
}

/**
 * Start the typing animation effect
 * @param targetText The complete text that should be displayed when animation completes
 */
private startTypingAnimation(targetText: string): void {
  // Store the current and target text
  this.currentTypingText = this.testScript;
  this.targetTypingText = targetText;
  this.typingPosition = this.currentTypingText.length;

  // Start the interval to add characters one by one
  this.typingInterval = setInterval(() => this.typeNextCharacter(), this.typingSpeed);
}

/**
 * Type the next character in the animation sequence
 */
private typeNextCharacter(): void {
  // Check if we've reached the end of the target text
  if (this.typingPosition >= this.targetTypingText.length) {
    this.stopTypingAnimation();
    return;
  }

  // Add the next character
  this.typingPosition++;
  this.testScript = this.targetTypingText.substring(0, this.typingPosition);
}

/**
 * Stop the typing animation
 */
private stopTypingAnimation(): void {
  if (this.typingInterval) {
    clearInterval(this.typingInterval);
    this.typingInterval = null;

    // Ensure the full text is displayed
    if (this.targetTypingText) {
      this.testScript = this.targetTypingText;
    }
  }
}

/**
 * Change the selected LLM type
 * @param llmType The LLM type to switch to
 */
changeLlmType(llmType: LlmType): void {
  this.selectedLlmType = llmType;
  this.llmFactoryService.setCurrentLlmType(llmType);
  this.updateCurrentModelName();
}

/**
 * Update the current model name display
 */
private updateCurrentModelName(): void {
  const currentLlm = this.llmFactoryService.getCurrentLlm();
  this.currentModelName = currentLlm.getModelName();
}

private cleanGeneratedCode(response: string): string {
  // Try to extract code blocks if they exist (markdown format ```csharp...```)
  const codeBlockRegex = /```(?:csharp|cs|c#)?([\s\S]*?)```/g;
  const codeBlocks = [];
  let match;

  while ((match = codeBlockRegex.exec(response)) !== null) {
    // Add the content inside the code block
    codeBlocks.push(match[1].trim());
  }

  // If we found code blocks, join them
  if (codeBlocks.length > 0) {
    return codeBlocks.join('\n\n');
  }

  // If no code blocks, try to clean up the response as best as possible
  // Remove any explanatory text before or after the code
  let cleanedCode = response;

  // Remove common prefixes that LLMs might add
  const prefixesToRemove = [
    'Here is the code:',
    'Here\'s the code:',
    'Here is a test script:',
    'Here\'s a test script:',
    'Here is the test code:',
    'Here\'s the test code:',
    'Here is the C# test code:',
    'Here\'s the C# test code:',
    'Here is the API test:',
    'Here\'s the API test:'
  ];

  for (const prefix of prefixesToRemove) {
    if (cleanedCode.includes(prefix)) {
      cleanedCode = cleanedCode.substring(cleanedCode.indexOf(prefix) + prefix.length).trim();
    }
  }

  // Look for C# test patterns to identify the actual code
  const csharpPatterns = ['TestAsync(', 'public async Task', '[Test]', '[TestMethod]', 'Assert(', 'AssertStatusCode('];
  
  for (const pattern of csharpPatterns) {
    if (cleanedCode.includes(pattern)) {
      // Find the first occurrence of the pattern
      const patternIndex = cleanedCode.indexOf(pattern);
      if (patternIndex > 0) {
        // Look for the start of the line containing the pattern
        const lineStartIndex = cleanedCode.lastIndexOf('\n', patternIndex);
        if (lineStartIndex > 0) {
          cleanedCode = cleanedCode.substring(lineStartIndex + 1);
        } else {
          cleanedCode = cleanedCode.substring(patternIndex);
        }
      }
      break;
    }
  }

  // Try to find where the code ends (if there's explanatory text after)
  const possibleEndMarkers = [
    'Note:', 'This code', 'These tests', 'The above', 'This test',
    'I hope this helps', 'Let me know', 'This example', 'You can modify'
  ];
  
  for (const marker of possibleEndMarkers) {
    const markerIndex = cleanedCode.indexOf(marker);
    if (markerIndex > 0 && markerIndex > cleanedCode.lastIndexOf('});')) {
      cleanedCode = cleanedCode.substring(0, markerIndex).trim();
      break;
    }
  }

  return cleanedCode;
}
